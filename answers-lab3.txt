Lab 3
Part A

1. Having an individual handler for each type of interrupt allows us to identify
   what kind of interrupt we hit, and what the error, if any , is associated
   with it. Using this information, we can make an informed decision about what
   we do with the interrupt.

2. We didn't have to do anything to make the user/softint program behave
   correctly. Although we call int $14, because we are in the user space, we
   generate a general protection fault, which is vector 13 in the interrupt
   table. If we actually allowed users to call arbitrary interrupts, we could
   get buggy or malicious behavior by abusing how the system handles a page
   fault in this case. If we allocated a new page on each page fault, a
   user program could crash the system by continuously allocating pages by
   calling int $14.

Part B

1. Here, unlike above, we are able to call the breakpoint interrupt from user
   space where the CPL = 3. We can do this because in the SETGATE instruction
   where we added the relevant breakpoint entry, we created it with a DPL of 3.
   If we were to have accidentally set the DPL to 0, we could only call
   breakpoints from the kernel and if we were to try executing an int3
   instruction from a user process, we would instead trigger a general
   protection fault.

2. These mechanisms exist, as I alluded to above, in order to protect the kernel
   from malicious or buggy user programs. There are some interrupts that should
   only be generated by the kernel, for example the page fault. By enforcing the
   protections on accessing members of the IDT, we can ensure that user programs
   cannot call inappropriate interrupts.
